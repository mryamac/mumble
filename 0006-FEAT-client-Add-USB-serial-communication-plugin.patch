From 6edd387d95b4af888fc48f45c2daedfaea10c9bf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Abdullah=20=C3=96mer=20Yama=C3=A7?= <aomeryamac@gmail.com>
Date: Tue, 16 Apr 2024 16:25:31 +0300
Subject: [PATCH 06/10] FEAT(client): Add USB serial communication plugin
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

his plugin allows the user to communicate with a serial device
connected to the computer via USB. The plugin uses the `libserialport`
library to communicate with the device.

Co-Authored-By: Abdullah Ömer Yamaç <aomeryamac@gmail.com>
---
 plugins/CMakeLists.txt              |   1 +
 plugins/serial_com/CMakeLists.txt   |  20 ++
 plugins/serial_com/SerialCom.cpp    | 399 ++++++++++++++++++++++++++++
 plugins/serial_com/USBSerialCom.cpp | 280 +++++++++++++++++++
 plugins/serial_com/USBSerialCom.h   |  59 ++++
 5 files changed, 759 insertions(+)
 create mode 100644 plugins/serial_com/CMakeLists.txt
 create mode 100644 plugins/serial_com/SerialCom.cpp
 create mode 100644 plugins/serial_com/USBSerialCom.cpp
 create mode 100644 plugins/serial_com/USBSerialCom.h

diff --git a/plugins/CMakeLists.txt b/plugins/CMakeLists.txt
index 9cd3216f8..d98a3c74a 100644
--- a/plugins/CMakeLists.txt
+++ b/plugins/CMakeLists.txt
@@ -70,6 +70,7 @@ if(WIN32 OR (UNIX AND CMAKE_SYSTEM_NAME STREQUAL "Linux"))
 		"lotro"
 		"ql"
 		"rl"
+		"serial_com"
 		"se"
 		"sr"
 		"sto"
diff --git a/plugins/serial_com/CMakeLists.txt b/plugins/serial_com/CMakeLists.txt
new file mode 100644
index 000000000..4f73adadd
--- /dev/null
+++ b/plugins/serial_com/CMakeLists.txt
@@ -0,0 +1,20 @@
+# Copyright 2021-2023 The Mumble Developers. All rights reserved.
+# Use of this source code is governed by a BSD-style license
+# that can be found in the LICENSE file at the root of the
+# Mumble source tree or at <https://www.mumble.info/LICENSE>.
+
+# Find the QtCore module
+find_package(Qt5 COMPONENTS Core REQUIRED)
+# Manually set include directories
+include_directories("/usr/include/libserial")
+include_directories("/usr/local/include/libserial")
+include_directories("/usr/lib/x86_64-linux-gnu/include/libserial") # Adjust this path as needed
+
+# Manually set library directories
+link_directories("/usr/lib")
+link_directories("/usr/local/lib")
+link_directories("/usr/lib/x86_64-linux-gnu") # Adjust this path as needed
+
+
+add_library(serial_com SHARED "SerialCom.cpp" "USBSerialCom.cpp" )
+target_link_libraries(serial_com Qt5::Core serial)
diff --git a/plugins/serial_com/SerialCom.cpp b/plugins/serial_com/SerialCom.cpp
new file mode 100644
index 000000000..9d521a9a4
--- /dev/null
+++ b/plugins/serial_com/SerialCom.cpp
@@ -0,0 +1,399 @@
+// Copyright 2021-2023 The Mumble Developers. All rights reserved.
+// Use of this source code is governed by a BSD-style license
+// that can be found in the LICENSE file at the root of the
+// Mumble source tree or at <https://www.mumble.info/LICENSE>.
+
+// Include the definitions of the plugin functions
+// Not that this will also include ../PluginComponents.h
+#include "../MumblePlugin.h"
+#include "USBSerialCom.h"
+
+#include <cstring>
+#include <iostream>
+#include <thread>
+
+// These are just some utility functions facilitating writing logs and the like
+// The actual implementation of the plugin is further down
+std::ostream &pLog() {
+	std::cout << "SerialCom Plugin: ";
+	return std::cout;
+}
+
+template< typename T > void pluginLog(T log) {
+	pLog() << log << std::endl;
+}
+
+std::ostream &operator<<(std::ostream &stream, const mumble_version_t version) {
+	stream << "v" << version.major << "." << version.minor << "." << version.patch;
+	return stream;
+}
+
+
+//////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////
+//////////////////// PLUGIN IMPLEMENTATION ///////////////////
+//////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////
+
+mumble_api_t mumAPI;
+mumble_plugin_id_t ownID;
+
+/*User Defined Variables*/
+mumble_userid_t userID;
+mumble_connection_t activeConnection;
+const char *dataID = "Call Plugin";
+
+//////////////////////////////////////////////////////////////
+//////////////////// OBLIGATORY FUNCTIONS ////////////////////
+//////////////////////////////////////////////////////////////
+// All of the following function must be implemented in order for Mumble to load the plugin
+
+mumble_error_t mumble_init(uint32_t id) {
+	pluginLog("Initialized plugin");
+
+	ownID = id;
+
+	// Print the connection ID at initialization. If not connected to a server it should be -1.
+	pLog() << "Plugin ID is " << id << std::endl;
+	try {
+		USBSerialCom::load();
+	} catch (const std::string &e) {
+		mumAPI.log(ownID, e.c_str());
+		return MUMBLE_EC_INTERNAL_ERROR;
+	}
+
+	USBSerialCom::startPooling();
+
+	// MUMBLE_STATUS_OK is a macro set to the appropriate status flag (ErrorCode)
+	// If you need to return any other status have a look at the ErrorCode enum
+	// inside PluginComponents.h and use one of its values
+	return MUMBLE_STATUS_OK;
+}
+
+void mumble_shutdown() {
+	pluginLog("Shutdown plugin");
+
+	USBSerialCom::stopPooling();
+
+	mumAPI.log(ownID, "Shutdown");
+}
+
+MumbleStringWrapper mumble_getName() {
+	static const char *name = "Serial Communication Plugin";
+
+	MumbleStringWrapper wrapper;
+	wrapper.data = name;
+	wrapper.size = strlen(name);
+	// It's a static String and therefore doesn't need releasing
+	wrapper.needsReleasing = false;
+
+	return wrapper;
+}
+
+mumble_version_t mumble_getAPIVersion() {
+	// MUMBLE_PLUGIN_API_VERSION will always contain the API version of the used header file (the one used to build
+	// this plugin against). Thus you should always return that here in order to no have to worry about it.
+	return MUMBLE_PLUGIN_API_VERSION;
+}
+
+void mumble_registerAPIFunctions(void *api) {
+	// In this function the plugin is presented with a struct of function pointers that can be used
+	// to interact with Mumble. Thus you should store it somewhere safe for later usage.
+
+	// The pointer has to be cast to the respective API struct. You always have to cast to the same API version
+	// as this plugin itself is using. Thus if this plugin is compiled using the API version 1.0.x (where x is an
+	// arbitrary version) the pointer has to be cast to MumbleAPI_v_1_0_x (where x is a literal "x"). Furthermore the
+	// struct HAS TO BE COPIED!!! Storing the pointer is not an option as it will become invalid quickly!
+
+	// **If** you are using the same API version that is specified in the included header file (as you should), you
+	// can simply use the MUMBLE_API_CAST to cast the pointer to the correct type and automatically dereferencing it.
+	mumAPI = MUMBLE_API_CAST(api);
+
+	pluginLog("Registered Mumble's API functions");
+}
+
+void mumble_releaseResource(const void *pointer) {
+	std::cerr << "[ERROR]: Unexpected call to mumble_releaseResources" << std::endl;
+	std::terminate();
+	// This plugin doesn't use resources that are explicitly allocated (only static Strings are used). Therefore
+	// we don't have to implement this function.
+	//
+	// If you allocated resources using malloc(), you're implementation for releasing that would be
+	// free(const_cast<void *>(pointer));
+	//
+	// If however you allocated a resource using the new operator (C++ only), you have figure out the pointer's
+	// original type and then invoke
+	// delete static_cast<ActualType *>(pointer);
+
+	// Mark as unused
+	(void) pointer;
+}
+
+bool mumble_onReceiveData(mumble_connection_t connection, mumble_userid_t sender, const uint8_t *data,
+						  size_t dataLength, const char *dataID) {
+	const char *senderName;
+	mumble_channelid_t tempChannelID;
+
+	if (dataLength >= 4 && strncmp(reinterpret_cast< const char * >(data), "CALL ", 5) == 0
+		&& USBSerialCom::getCallUser() == 0) {
+		// Split data CALL sender channelID
+		sscanf(reinterpret_cast< const char * >(data), "CALL %u", &tempChannelID);
+
+		// Get the name of the sender
+		mumAPI.getUserName(ownID, connection, sender, &senderName);
+
+		USBSerialCom::setCall(sender, tempChannelID);
+
+		USBSerialCom::response("CALL FROM " + std::string(senderName));
+	} else if (dataLength >= 4 && strncmp(reinterpret_cast< const char * >(data), "CALL ", 5) == 0
+			   && USBSerialCom::getCallUser() != 0) {
+		sendDataToUser(USBSerialCom::getCallUser(), "BUSY");
+	} else if (dataLength >= 6 && strncmp(reinterpret_cast< const char * >(data), "ACCEPT", 6) == 0
+			   && USBSerialCom::getCallUser() == sender) {
+		USBSerialCom::response("ACCEPTED");
+	} else if (dataLength >= 6 && strncmp(reinterpret_cast< const char * >(data), "REJECT", 6) == 0
+			   && USBSerialCom::getCallUser() == sender) {
+		USBSerialCom::response("REJECTED");
+		USBSerialCom::endCall();
+	} else if (dataLength >= 7 && strncmp(reinterpret_cast< const char * >(data), "ENDCALL", 6) == 0
+			   && USBSerialCom::getCallUser() == sender) {
+		USBSerialCom::response("ENDCALL");
+		USBSerialCom::clearCallState();
+	} else if (dataLength >= 4 && strncmp(reinterpret_cast< const char * >(data), "BUSY", 6) == 0) {
+		USBSerialCom::clearCallState();
+		USBSerialCom::response("BUSY");
+	}
+
+
+	return true;
+}
+
+void mumble_onServerSynchronized(mumble_connection_t connection) {
+	mumble_error_t result = MUMBLE_EC_API_REQUEST_TIMEOUT;
+	while (result != MUMBLE_EC_OK) {
+		result = mumAPI.getActiveServerConnection(ownID, &activeConnection);
+	}
+
+	result = mumAPI.getLocalUserID(ownID, activeConnection, &userID);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to get local user id");
+		return;
+	}
+}
+//////////////////////////////////////////////////////////////
+///////////////////// OPTIONAL FUNCTIONS /////////////////////
+//////////////////////////////////////////////////////////////
+// The implementation of below functions is optional. If you don't need them, don't include them in your
+// plugin
+
+mumble_version_t mumble_getVersion() {
+	// Mumble uses semantic versioning (see https://semver.org/)
+	// { major, minor, patch }
+	return { 1, 3, 0 };
+}
+
+MumbleStringWrapper mumble_getAuthor() {
+	static const char *author = "Abdullah Ömer Yamaç";
+
+	MumbleStringWrapper wrapper;
+	wrapper.data = author;
+	wrapper.size = strlen(author);
+	// It's a static String and therefore doesn't need releasing
+	wrapper.needsReleasing = false;
+
+	return wrapper;
+}
+
+MumbleStringWrapper mumble_getDescription() {
+	static const char *description = "This plugin is merely a reference implementation without any real functionality. "
+									 "It shouldn't be included in the release build of Mumble.";
+
+	MumbleStringWrapper wrapper;
+	wrapper.data = description;
+	wrapper.size = strlen(description);
+	// It's a static String and therefore doesn't need releasing
+	wrapper.needsReleasing = false;
+
+	return wrapper;
+}
+
+mumble_channelid_t getChannelID(const char *channelID) {
+	// Get all channels from mumble-api
+	mumble_error_t result;
+	size_t channelCount;
+	mumble_channelid_t *channels;
+	result = mumAPI.getAllChannels(ownID, activeConnection, &channels, &channelCount);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to get all channels");
+		return -1;
+	}
+
+	// Find the channel with the given name
+	for (size_t i = 0; i < channelCount; i++) {
+		const char *channelName;
+		result = mumAPI.getChannelName(ownID, activeConnection, channels[i], &channelName);
+		if (result != MUMBLE_STATUS_OK) {
+			mumAPI.log(ownID, "Failed to get channel name");
+			return -1;
+		}
+		if (strcmp(channelName, channelID) == 0) {
+			return channels[i];
+		}
+	}
+	mumAPI.log(ownID, "Failed to find channel");
+	return -1;
+}
+
+int setUserToChannel(mumble_channelid_t channelID) {
+	mumble_error_t result;
+
+	// Set the user to the given channel
+	result = mumAPI.requestUserMove(ownID, activeConnection, userID, channelID, NULL);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to set user to channel");
+		return -1;
+	}
+
+	return 0;
+}
+
+int unlinkChannels(std::vector< mumble_channelid_t > channels) {
+	mumble_error_t result;
+	mumble_channelid_t currentChannel;
+
+	result = mumAPI.getChannelOfUser(ownID, activeConnection, userID, &currentChannel);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to get channel of user");
+		return -1;
+	}
+
+	channels.push_back(currentChannel);
+	// Unlink the channel
+	result = mumAPI.requestUnlinkGivenChannels(ownID, activeConnection, channels.data(), channels.size());
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to unlink channel");
+		return -1;
+	}
+
+	return 0;
+}
+
+int linkChannels(std::vector< mumble_channelid_t > channels) {
+	mumble_error_t result;
+	mumble_channelid_t currentChannel;
+
+	result = mumAPI.getChannelOfUser(ownID, activeConnection, userID, &currentChannel);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to get channel of user");
+		return -1;
+	}
+
+	channels.push_back(currentChannel);
+	// Link the channel
+	result = mumAPI.requestLinkChannels(ownID, activeConnection, channels.data(), channels.size());
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to link channel");
+		return -1;
+	}
+
+	return 0;
+}
+
+int startListeningToChannel(std::vector< mumble_channelid_t > channels) {
+	mumble_error_t result;
+
+	// Listen to the channel
+	result = mumAPI.requestStartListeningToChannels(ownID, activeConnection, channels.data(), channels.size());
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to listen to channel");
+		return -1;
+	}
+
+	return 0;
+}
+
+int stopListeningToChannel(std::vector< mumble_channelid_t > channels) {
+	// Get current channel
+	mumble_error_t result;
+
+	// Stop listening to the channel
+	result = mumAPI.requestStopListeningToChannels(ownID, activeConnection, channels.data(), channels.size());
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to stop listening to channel");
+		return -1;
+	}
+
+	return 0;
+}
+
+int createTempChannel(const char *channelName) {
+	mumble_error_t result;
+
+	// Create the channel
+	result = mumAPI.requestCreateChannel(ownID, activeConnection, 0, channelName, NULL, 0, false, 2);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to create channel");
+		return -1;
+	}
+
+	return 0;
+}
+
+mumble_channelid_t getCurrentChannelID() {
+	mumble_error_t result;
+	mumble_channelid_t currentChannel;
+
+	result = mumAPI.getChannelOfUser(ownID, activeConnection, userID, &currentChannel);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to get channel of user");
+		return -1;
+	}
+
+	return currentChannel;
+}
+
+int sendDataToUser(const char *userName, const char *message) {
+	mumble_error_t result;
+	size_t userCount;
+	mumble_userid_t user;
+
+	result = mumAPI.findUserByName(ownID, activeConnection, userName, &user);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to find user");
+		return -1;
+	}
+	(ownID, activeConnection, user, message);
+	// Send the message
+	result = mumAPI.sendData(ownID, activeConnection, &user, 1, (const uint8_t *) message, strlen(message), dataID);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to send message to user");
+		return -1;
+	}
+
+	return user;
+}
+
+int sendDataToUser(mumble_userid_t user, const char *message) {
+	mumble_error_t result;
+
+	// Send the message
+	result = mumAPI.sendData(ownID, activeConnection, &user, 1, (const uint8_t *) message, strlen(message), dataID);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to send message to user");
+		return -1;
+	}
+
+	return 0;
+}
+
+int getCurrentUserName(const char **userName) {
+	mumble_error_t result;
+	result = mumAPI.getUserName(ownID, activeConnection, userID, userName);
+	if (result != MUMBLE_STATUS_OK) {
+		mumAPI.log(ownID, "Failed to get user name");
+		return -1;
+	}
+
+	return 0;
+}
+//////////////////////////////////////////////////////////////
\ No newline at end of file
diff --git a/plugins/serial_com/USBSerialCom.cpp b/plugins/serial_com/USBSerialCom.cpp
new file mode 100644
index 000000000..b9611f1c3
--- /dev/null
+++ b/plugins/serial_com/USBSerialCom.cpp
@@ -0,0 +1,280 @@
+#include "USBSerialCom.h"
+#include <QFile>
+#include <fstream>
+#include <iostream>
+#include <qstandardpaths.h>
+#include <sstream>
+#include <thread>
+#include <unordered_map>
+
+std::atomic< bool > USBSerialCom::shouldStop;
+std::thread USBSerialCom::myThread;
+std::string USBSerialCom::devPath          = "";
+unsigned int USBSerialCom::baudRate        = 0;
+mumble_channelid_t USBSerialCom::channelID = 0;
+const char *USBSerialCom::userName;
+mumble_userid_t USBSerialCom::callUserID       = 0;
+mumble_channelid_t USBSerialCom::callChannelID = 0;
+LibSerial::SerialStream USBSerialCom::serialStream;
+
+void USBSerialCom::load() {
+	std::string settingsPath = findSettingsLocation(false);
+
+	std::ifstream stream(settingsPath);
+
+	// Check if the file is open
+	if (!stream.is_open()) {
+		throw std::string("Could not open settings file" + settingsPath);
+	}
+
+	// Container to store key-value pairs
+	std::unordered_map< std::string, std::string > keyValuePairs;
+
+	// Read and parse each line from the file
+	std::string line;
+	while (std::getline(stream, line)) {
+		std::istringstream iss(line);
+		std::string key, value;
+		if (std::getline(iss, key, '=') && std::getline(iss, value)) {
+			// Trim leading and trailing whitespaces from key and value
+			key.erase(0, key.find_first_not_of(" \t\n\r\f\v"));
+			key.erase(key.find_last_not_of(" \t\n\r\f\v") + 1);
+			value.erase(0, value.find_first_not_of(" \t\n\r\f\v"));
+			value.erase(value.find_last_not_of(" \t\n\r\f\v") + 1);
+
+			// Insert key-value pair into the map
+			keyValuePairs[key] = value;
+		}
+	}
+
+	devPath   = keyValuePairs["devPath"];
+	baudRate  = std::stoul(keyValuePairs["baudRate"].c_str());
+	channelID = std::stoul(keyValuePairs["channelID"].c_str());
+
+	stream.close();
+}
+
+std::string USBSerialCom::findSettingsLocation(bool legacy) {
+	QString path = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);
+	QFile settingsFile(QString::fromLatin1("%1/%2").arg(path).arg(QLatin1String("Mumble/settings.ini")));
+
+	return settingsFile.fileName().toStdString();
+}
+
+void USBSerialCom::startPooling() {
+	// Start pooling the serial port
+	shouldStop.store(false);
+	serialStream.Open(devPath.c_str());
+	LibSerial::BaudRate baudRateEnum = LibSerial::BaudRate::BAUD_9600;
+	switch (baudRate) {
+		case 9600:
+			baudRateEnum = LibSerial::BaudRate::BAUD_9600;
+			break;
+		case 19200:
+			baudRateEnum = LibSerial::BaudRate::BAUD_19200;
+			break;
+		case 38400:
+			baudRateEnum = LibSerial::BaudRate::BAUD_38400;
+			break;
+		case 57600:
+			baudRateEnum = LibSerial::BaudRate::BAUD_57600;
+			break;
+		case 115200:
+			baudRateEnum = LibSerial::BaudRate::BAUD_115200;
+			break;
+		default:
+			// Do something else
+			break;
+	}
+	serialStream.SetBaudRate(LibSerial::BaudRate::BAUD_115200);
+	myThread = std::thread(loop);
+}
+
+void USBSerialCom::stopPooling() {
+	// Stop pooling the serial port
+	shouldStop.store(true);
+	if (myThread.joinable()) {
+		myThread.join();
+	}
+	serialStream.Close();
+}
+
+int USBSerialCom::callToUser(const char *user) {
+	int result;
+	int nb_tries = 5;
+	mumble_channelid_t currentChannel;
+	std::string channelName;
+	mumble_channelid_t callChannelID;
+	std::string message;
+
+	// Check if the user is already in a call
+	if (callUserID != 0) {
+		response("ALREADY IN A CALL");
+		return -1;
+	}
+
+	// Set the user to the call channel
+	if (userName == nullptr) {
+		result = getCurrentUserName(&userName);
+		if (result == -1)
+			return -1;
+	}
+	currentChannel = getCurrentChannelID();
+	if (currentChannel == -1)
+		return -1;
+	channelName = "Call-" + std::string(userName) + "-" + std::string(user);
+	result      = createTempChannel(channelName.c_str());
+	if (result == -1)
+		return -1;
+	while (getCurrentChannelID() == currentChannel && nb_tries > 0) {
+		std::this_thread::sleep_for(std::chrono::seconds(1));
+		nb_tries--;
+	}
+	if (currentChannel == getCurrentChannelID())
+		return -1;
+
+	// Get the call channel ID
+	callChannelID = getCurrentChannelID();
+	if (callChannelID == -1)
+		return -1;
+
+	// Send a message to the user
+	message = "CALL " + std::to_string(callChannelID);
+	result  = sendDataToUser(user, message.c_str());
+	if (result == -1)
+		return -1;
+
+	callUserID = result;
+	startListeningToChannel({ channelID });
+
+	return 0;
+}
+
+void USBSerialCom::endCall() {
+	// Remove the call channel
+	if(callChannelID == 0)
+		return;
+
+	std::string message = "ENDCALL";
+	sendDataToUser(callUserID, message.c_str());
+	clearCallState();
+}
+
+int USBSerialCom::acceptCall() {
+	// Accept the call
+	if (callUserID == 0)
+		return -1;
+
+	setUserToChannel(callChannelID);
+	startListeningToChannel({ channelID });
+	sendDataToUser(callUserID, "ACCEPT");
+	return 0;
+}
+
+int USBSerialCom::rejectCall() {
+	sendDataToUser(callUserID, "REJECT");
+	clearCallState();
+	return 0;
+}
+
+void USBSerialCom::clearCallState() {
+	callUserID    = 0;
+	callChannelID = 0;
+	setUserToChannel(channelID);
+	stopListeningToChannel({ channelID });
+}
+
+void USBSerialCom::loop() {
+	// This is the function that will be called in a separate thread
+	// It will pool the serial port for new data
+
+serialStream.Open(devPath.c_str());
+	while (!shouldStop.load()) {
+		// Read data from the serial port
+		std::string data;
+		int result;
+		 std::getline(serialStream, data);
+		//std::getline(std::cin, data);
+
+		// Process the read data
+		if (!data.empty()) {
+			std::istringstream iss(data);
+			std::vector< mumble_channelid_t > tokens; // Vector to store each token
+			std::string token;
+			std::string command;
+
+			iss >> command; // Read the first token as the command
+
+			if (command.empty())
+				continue;
+
+			if (strcmp(command.c_str(), "CHANNEL") == 0) {
+				iss >> token;
+				if (!token.empty())
+					setUserToChannel(std::stoi(token));
+			} else if (strcmp(command.c_str(), "LINK") == 0) {
+				while (iss >> token)
+					tokens.push_back(std::stoi(token));
+				if (tokens.size() < 1)
+					continue;
+				linkChannels(tokens);
+			} else if (strcmp(command.c_str(), "UNLINK") == 0) {
+				while (iss >> token)
+					tokens.push_back(std::stoi(token));
+				if (tokens.size() < 1)
+					continue;
+				unlinkChannels(tokens);
+			} else if (strcmp(command.c_str(), "LISTEN") == 0) {
+				while (iss >> token)
+					tokens.push_back(std::stoi(token));
+				if (tokens.size() < 1)
+					continue;
+				startListeningToChannel(tokens);
+			} else if (strcmp(command.c_str(), "NLISTEN") == 0) {
+				while (iss >> token)
+					tokens.push_back(std::stoi(token));
+				if (tokens.size() < 1)
+					continue;
+				stopListeningToChannel(tokens);
+			} else if (strcmp(command.c_str(), "CALL") == 0) {
+				iss >> token;
+				if (token.empty())
+					continue;
+
+				result = callToUser(token.c_str());
+				if (result == -1) {
+					response("CALL FAILED");
+					clearCallState();
+				}
+			} else if (strcmp(command.c_str(), "ENDCALL") == 0) {
+				endCall();
+			} else if (strcmp(command.c_str(), "ACCEPT") == 0) {
+				acceptCall();
+			} else if (strcmp(command.c_str(), "REJECT") == 0) {
+				rejectCall();
+			} else {
+				// Do something else
+			}
+		}
+
+		// Add a delay to simulate continuous reading
+		std::this_thread::sleep_for(std::chrono::seconds(1));
+	}
+	return;
+}
+
+void USBSerialCom::response(std::string message) {
+	// Send a response to the serial port
+	 serialStream << message;
+	// std::cout << message << std::endl;
+}
+
+mumble_userid_t USBSerialCom::getCallUser() {
+	return callUserID;
+}
+
+void USBSerialCom::setCall(mumble_userid_t user, mumble_channelid_t channelID) {
+	// Set the last call
+	callUserID    = user;
+	callChannelID = channelID;
+}
\ No newline at end of file
diff --git a/plugins/serial_com/USBSerialCom.h b/plugins/serial_com/USBSerialCom.h
new file mode 100644
index 000000000..0170f30bb
--- /dev/null
+++ b/plugins/serial_com/USBSerialCom.h
@@ -0,0 +1,59 @@
+#ifndef MUMBLE_MUMBLE_PLUGIN_SERIAL_COM_SETTINGS_H_
+#define MUMBLE_MUMBLE_PLUGIN_SERIAL_COM_SETTINGS_H_
+
+#include <atomic> // For std::atomic<bool>
+#include <string>
+#include <thread>
+#include <vector>
+#include <SerialStream.h>
+
+typedef int32_t mumble_channelid_t;
+typedef uint32_t mumble_userid_t;
+
+mumble_channelid_t getChannelID(const char *channelID);
+int setUserToChannel(mumble_channelid_t channelID);
+int linkChannels(std::vector< mumble_channelid_t > channels);
+int unlinkChannels(std::vector< mumble_channelid_t > channels);
+int startListeningToChannel(std::vector< mumble_channelid_t > channels);
+int stopListeningToChannel(std::vector< mumble_channelid_t > channels);
+int createTempChannel(const char *channelName);
+int sendDataToUser(const char *userName, const char *message);
+int sendDataToUser(mumble_userid_t user, const char *message);
+int getCurrentUserName(const char **userName);
+mumble_channelid_t getCurrentChannelID();
+
+class USBSerialCom {
+private:
+	static LibSerial::SerialStream serialStream;
+	static std::atomic< bool > shouldStop;
+	static std::thread myThread;
+	static std::string devPath;
+	static unsigned int baudRate;
+	static mumble_channelid_t channelID;
+	const static char *userName;
+	static mumble_userid_t callUserID;
+	static mumble_channelid_t callChannelID;
+	static std::string findSettingsLocation(bool legacy);
+	static void loop();
+
+public:
+	USBSerialCom(/* args */){};
+	~USBSerialCom(){};
+
+	static void load();
+	static void startPooling();
+	static void stopPooling();
+	static void response(std::string message);
+
+	static mumble_userid_t getCallUser();
+	static void setCall(mumble_userid_t user, mumble_channelid_t channelID);
+
+	static void clearCallState();
+	static int callToUser(const char *userName);
+	static void endCall();
+	static int acceptCall();
+	static int rejectCall();
+};
+
+
+#endif // MUMBLE_MUMBLE_PLUGIN_SERIAL_COM_SETTINGS_H_
\ No newline at end of file
-- 
2.34.1

